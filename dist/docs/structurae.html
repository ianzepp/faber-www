<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Structurae - Faber</title>
  <meta name="description" content="Faber programming language documentation">
  <link rel="stylesheet" href="/styles.css">
  <link rel="alternate" type="text/plain" href="/llms.txt" title="LLM Site Index">
  <link rel="alternate" type="text/markdown" href="/faber-complete.md" title="Complete Documentation (Markdown)">
</head>
<body>
  <div class="banner">Pre-alpha: Published for early evaluation only</div>
  <div class="container">
    <nav class="site-nav">
  <a href="/" class="nav-home">Faber</a>
  <div class="nav-section">docs</div>
  <a href="/docs/index.html">Documentation</a>
  <a href="/docs/grammar.html">Grammar Reference</a>
  <a href="/docs/examples.html">Examples</a>
  <a href="/docs/examples-full.html">All Examples</a>
  <a href="/docs/fundamenta.html">Fundamenta</a>
  <a href="/docs/typi.html">Typi</a>
  <a href="/docs/operatores.html">Operatores</a>
  <a href="/docs/structurae.html" class="active">Structurae</a>
  <div class="nav-subheadings">
    <a href="/docs/structurae.html#exempla">Exempla</a>
    <a href="/docs/structurae.html#syntax">Syntax</a>
    <a href="/docs/structurae.html#genus-declaration" class="nav-h3">Genus Declaration</a>
    <a href="/docs/structurae.html#genus-member" class="nav-h3">Genus Member</a>
    <a href="/docs/structurae.html#pactum-declaration" class="nav-h3">Pactum Declaration</a>
    <a href="/docs/structurae.html#pactum-method" class="nav-h3">Pactum Method</a>
    <a href="/docs/structurae.html#call" class="nav-h3">Call</a>
    <a href="/docs/structurae.html#argument-list" class="nav-h3">Argument List</a>
    <a href="/docs/structurae.html#primary" class="nav-h3">Primary</a>
    <a href="/docs/structurae.html#identifier" class="nav-h3">Identifier</a>
  </div>
  <a href="/docs/regimen.html">Regimen</a>
  <a href="/docs/functiones.html">Functiones</a>
  <a href="/docs/importa.html">Importa</a>
  <a href="/docs/errores.html">Errores</a>
  <a href="/docs/preamble.html">Faber Romanus Grammar</a>
  <div class="nav-section">research</div>
  <a href="/research/index.html">Research</a>
  <a href="/research/results.html">Research Results</a>
</nav>
    <main class="content">
      <h1 id="structurae">Structurae</h1>
<p>Data structures: classes (genus), objects, member access, and instantiation.</p>
<h2 id="exempla">Exempla</h2>
<ul>
<li><code>exempla/structurae/</code></li>
</ul>
<hr>
<h2 id="syntax">Syntax</h2>
<h3 id="genus-declaration">Genus Declaration</h3>
<pre><code class="language-ebnf">genusDecl := &#39;abstractus&#39;? &#39;genus&#39; IDENTIFIER typeParams? (&#39;sub&#39; IDENTIFIER)? (&#39;implet&#39; IDENTIFIER (&#39;,&#39; IDENTIFIER)*)? &#39;{&#39; genusMember* &#39;}&#39;
typeParams := &#39;&lt;&#39; IDENTIFIER (&#39;,&#39; IDENTIFIER)* &#39;&gt;&#39;
genusMember := fieldDecl | methodDecl
</code></pre>
<blockquote>
<p>Latin &#39;genus&#39; (kind/type) for data structures.
&#39;sub&#39; (under) for inheritance - child is under parent.
&#39;implet&#39; (fulfills) for implementing pactum interfaces.
&#39;abstractus&#39; for abstract classes that cannot be instantiated.</p>
</blockquote>
<h3 id="genus-member">Genus Member</h3>
<pre><code class="language-ebnf">genusMember := annotation* (fieldDecl | methodDecl)
annotation := &#39;@&#39; IDENTIFIER+
fieldDecl := &#39;generis&#39;? &#39;nexum&#39;? typeAnnotation IDENTIFIER (&#39;:&#39; expression)?
methodDecl := &#39;functio&#39; IDENTIFIER &#39;(&#39; paramList &#39;)&#39; funcModifier* returnClause? blockStmt?
funcModifier := &#39;futura&#39; | &#39;cursor&#39; | &#39;curata&#39; IDENTIFIER
</code></pre>
<blockquote>
<p>Distinguishes between fields and methods by looking for &#39;functio&#39; keyword.
Fields are public by default (struct semantics).
Use annotations for visibility: @ privatum, @ protectum.
Use annotations for abstract methods: @ abstracta (no body, must be overridden).</p>
</blockquote>
<h3 id="pactum-declaration">Pactum Declaration</h3>
<pre><code class="language-ebnf">pactumDecl := &#39;pactum&#39; IDENTIFIER typeParams? &#39;{&#39; pactumMethod* &#39;}&#39;
typeParams := &#39;&lt;&#39; IDENTIFIER (&#39;,&#39; IDENTIFIER)* &#39;&gt;&#39;
</code></pre>
<blockquote>
<p>Latin &#39;pactum&#39; (agreement/contract) for interfaces.
Defines method signatures that genus types can implement via &#39;implet&#39;.</p>
</blockquote>
<p><strong>Examples:</strong></p>
<pre><code class="language-fab">pactum Legibilis { functio lege() -&gt; textus }
pactum Mappabilis&lt;T, U&gt; { functio mappa(T valor) -&gt; U }
</code></pre>
<h3 id="pactum-method">Pactum Method</h3>
<pre><code class="language-ebnf">pactumMethod := &#39;functio&#39; IDENTIFIER &#39;(&#39; paramList &#39;)&#39; funcModifier* returnClause?
funcModifier := &#39;futura&#39; | &#39;cursor&#39; | &#39;curata&#39; IDENTIFIER
returnClause := (&#39;-&gt;&#39; | &#39;fit&#39; | &#39;fiet&#39; | &#39;fiunt&#39; | &#39;fient&#39;) typeAnnotation
</code></pre>
<blockquote>
<p>Method signatures without bodies. Same syntax as function declarations
but terminates after return type (no block).</p>
</blockquote>
<h3 id="call">Call</h3>
<pre><code class="language-ebnf">call := primary (callSuffix | memberSuffix | optionalSuffix | nonNullSuffix)*
callSuffix := &#39;(&#39; argumentList &#39;)&#39;
memberSuffix := &#39;.&#39; IDENTIFIER | &#39;[&#39; expression &#39;]&#39;
optionalSuffix := &#39;?.&#39; IDENTIFIER | &#39;?[&#39; expression &#39;]&#39; | &#39;?(&#39; argumentList &#39;)&#39;
nonNullSuffix := &#39;!.&#39; IDENTIFIER | &#39;![&#39; expression &#39;]&#39; | &#39;!(&#39; argumentList &#39;)&#39;
</code></pre>
<blockquote>
<p>Handles function calls, member access, and computed member access.
Left-associative via loop (obj.a.b parsed as (obj.a).b).</p>
<p>OPTIONAL CHAINING: ?. ?[ ?( return nihil if object is nihil
NON-NULL ASSERTION: !. ![ !( assert object is not nihil</p>
</blockquote>
<h3 id="argument-list">Argument List</h3>
<pre><code class="language-ebnf">argumentList := (argument (&#39;,&#39; argument)*)?
argument := &#39;sparge&#39; expression | expression
</code></pre>
<h3 id="primary">Primary</h3>
<pre><code class="language-ebnf">primary := IDENTIFIER | NUMBER | STRING | TEMPLATE_STRING
| &#39;ego&#39; | &#39;verum&#39; | &#39;falsum&#39; | &#39;nihil&#39;
| &#39;(&#39; (expression | arrowFunction) &#39;)&#39;
</code></pre>
<blockquote>
<p>Latin literals: verum (true), falsum (false), nihil (null).
&#39;ego&#39; (I/self) is the self-reference keyword (like &#39;this&#39; in JS).
Parenthesized expressions require lookahead to distinguish from arrow functions.</p>
</blockquote>
<h3 id="identifier">Identifier</h3>
<pre><code class="language-ebnf">identifier := IDENTIFIER
</code></pre>
<hr>
<p><em>Generated from <code>fons/faber/parser/index.ts</code> â€” do not edit directly.</em></p>

    </main>
  </div>
</body>
</html>
