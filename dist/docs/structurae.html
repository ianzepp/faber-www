<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Structurae - Faber</title>
  <meta name="description" content="Faber programming language documentation">
  <link rel="stylesheet" href="/styles.css">
  <link rel="alternate" type="text/plain" href="/llms.txt" title="LLM Site Index">
  <link rel="alternate" type="text/markdown" href="/faber-complete.md" title="Complete Documentation (Markdown)">
</head>
<body>
  <div class="banner">Pre-alpha: Published for early evaluation only</div>
  <div class="container">
    <nav class="site-nav">
  <a href="/" class="nav-home">Faber</a>
  <div class="nav-section">docs</div>
  <a href="/docs/index.html">Documentation</a>
  <a href="/docs/grammar.html">Grammar Reference</a>
  <a href="/docs/examples.html">Examples</a>
  <a href="/docs/examples-full.html">All Examples</a>
  <a href="/docs/fundamenta.html">Fundamenta</a>
  <a href="/docs/typi.html">Typi</a>
  <a href="/docs/operatores.html">Operatores</a>
  <a href="/docs/structurae.html" class="active">Structurae</a>
  <div class="nav-subheadings">
    <a href="/docs/structurae.html#genus-data-types">genus (Data Types)</a>
    <a href="/docs/structurae.html#declaration" class="nav-h3">Declaration</a>
    <a href="/docs/structurae.html#field-defaults" class="nav-h3">Field Defaults</a>
    <a href="/docs/structurae.html#methods" class="nav-h3">Methods</a>
    <a href="/docs/structurae.html#self-reference-with-ego" class="nav-h3">Self-Reference with ego</a>
    <a href="/docs/structurae.html#static-members-with-generis" class="nav-h3">Static Members with generis</a>
    <a href="/docs/structurae.html#field-visibility" class="nav-h3">Field Visibility</a>
    <a href="/docs/structurae.html#method-visibility" class="nav-h3">Method Visibility</a>
    <a href="/docs/structurae.html#abstract-types" class="nav-h3">Abstract Types</a>
    <a href="/docs/structurae.html#generics" class="nav-h3">Generics</a>
    <a href="/docs/structurae.html#pactum-interfaces">pactum (Interfaces)</a>
    <a href="/docs/structurae.html#declaration" class="nav-h3">Declaration</a>
    <a href="/docs/structurae.html#implementation-with-implet" class="nav-h3">Implementation with implet</a>
    <a href="/docs/structurae.html#instantiation">Instantiation</a>
    <a href="/docs/structurae.html#creating-instances-with-novum" class="nav-h3">Creating Instances with novum</a>
    <a href="/docs/structurae.html#construction-from-variables" class="nav-h3">Construction from Variables</a>
    <a href="/docs/structurae.html#the-creo-hook" class="nav-h3">The creo() Hook</a>
    <a href="/docs/structurae.html#design-philosophy">Design Philosophy</a>
  </div>
  <a href="/docs/regimen.html">Regimen</a>
  <a href="/docs/functiones.html">Functiones</a>
  <a href="/docs/importa.html">Importa</a>
  <a href="/docs/errores.html">Errores</a>
  <div class="nav-section">research</div>
  <a href="/research/index.html">Research</a>
  <a href="/research/results.html">Research Results</a>
  <a href="/research/framework-1.1.html">Framework 1.1 Results</a>
</nav>
    <main class="content">
      <h1 id="structurae">Structurae</h1>
<p>Faber provides two fundamental building blocks for defining data structures: <code>genus</code> for concrete data types with fields and methods, and <code>pactum</code> for behavioral contracts that define what a type can do. This document explains how to declare, instantiate, and work with both.</p>
<p>The Latin terminology reflects the conceptual distinction: a <code>genus</code> (meaning &quot;birth, origin, kind&quot;) describes what something <em>is</em>, while a <code>pactum</code> (meaning &quot;agreement, contract&quot;) describes what something <em>promises to do</em>.</p>
<hr>
<h2 id="genus-data-types">genus (Data Types)</h2>
<p>A <code>genus</code> declaration creates a data type with fields and optional methods. Unlike class-based languages that emphasize inheritance hierarchies, Faber&#39;s <code>genus</code> follows struct semantics: fields are public by default, and composition is preferred over inheritance.</p>
<h3 id="declaration">Declaration</h3>
<p>The basic form declares a type name followed by its fields inside braces:</p>
<pre><code class="language-fab">genus Punctum {
    numerus x
    numerus y
}
</code></pre>
<p>Each field declaration specifies the type first, then the field name. This follows Faber&#39;s type-first convention, making the shape of data immediately visible.</p>
<p>A <code>genus</code> can contain any number of fields:</p>
<pre><code class="language-fab">genus Persona {
    textus nomen
    numerus aetas
    bivalens activus
}
</code></pre>
<p>Type names in Faber are conventionally lowercase, following Latin&#39;s case conventions where common nouns are not capitalized. The parser is case-insensitive, but the canonical style uses lowercase: <code>genus persona</code>, not <code>genus Persona</code>.</p>
<h3 id="field-defaults">Field Defaults</h3>
<p>Fields can specify default values using the colon (<code>:</code>) syntax:</p>
<pre><code class="language-fab">genus Persona {
    textus nomen: &quot;Incognitus&quot;
    numerus aetas: 0
    bivalens activus: verum
}
</code></pre>
<p>When a default is provided, the field becomes optional during instantiation. Fields without defaults are required.</p>
<p>The colon syntax deserves explanation. Faber distinguishes between two operations:</p>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Meaning</th>
<th>Context</th>
</tr>
</thead>
<tbody><tr>
<td><code>:</code></td>
<td>&quot;has value&quot; / &quot;defaults to&quot;</td>
<td>Field defaults, object literals, construction</td>
</tr>
<tr>
<td><code>=</code></td>
<td>&quot;assign value&quot;</td>
<td>Variable binding, reassignment, method bodies</td>
</tr>
</tbody></table>
<p>The colon represents a <em>declarative specification</em>: this field has this value by nature of its definition. The equals sign represents an <em>imperative action</em>: assign this value to that location.</p>
<p>This distinction creates consistency across the language. Object literals use colons (<code>{ nomen: &quot;Marcus&quot; }</code>), construction overrides use colons, and field defaults use colons. All three are specifying property values, not performing assignment.</p>
<h3 id="methods">Methods</h3>
<p>A <code>genus</code> can include methods alongside its fields. Methods are declared with the <code>functio</code> keyword:</p>
<pre><code class="language-fab">genus Rectangle {
    numerus width: 1
    numerus height: 1

    functio area() -&gt; numerus {
        redde ego.width * ego.height
    }

    functio perimeter() -&gt; numerus {
        redde 2 * (ego.width + ego.height)
    }

    functio isSquare() -&gt; bivalens {
        redde ego.width == ego.height
    }
}
</code></pre>
<p>Methods can return values, modify state, or both:</p>
<pre><code class="language-fab">genus Counter {
    numerus count: 0

    functio increment() {
        ego.count = ego.count + 1
    }

    functio getValue() -&gt; numerus {
        redde ego.count
    }
}
</code></pre>
<p>Methods are public by default, matching the struct semantics of <code>genus</code>. Use the <code>@ privata</code> annotation for internal helper methods.</p>
<h3 id="self-reference-with-ego">Self-Reference with ego</h3>
<p>Within methods, <code>ego</code> refers to the current instance. The word is Latin for &quot;I&quot; or &quot;self&quot;, making the self-reference explicit in every usage.</p>
<pre><code class="language-fab">functio celebraNatalem() {
    ego.aetas = ego.aetas + 1
}
</code></pre>
<p>Unlike languages where <code>this</code> is implicit or optional, Faber requires explicit <code>ego</code> for all instance member access. This eliminates ambiguity between local variables and instance fields, and makes the flow of data through an object visible.</p>
<h3 id="static-members-with-generis">Static Members with generis</h3>
<p>Members that belong to the type itself rather than instances use the <code>generis</code> keyword. The word is the genitive form of <code>genus</code>, literally meaning &quot;of the type&quot;:</p>
<pre><code class="language-fab">genus Colores {
    generis fixum ruber = &quot;#FF0000&quot;
    generis fixum viridis = &quot;#00FF00&quot;
    generis fixum caeruleus = &quot;#0000FF&quot;
}

genus Math {
    generis fixum PI = 3.14159
    generis fixum E = 2.71828

    generis functio maximus(numerus a, numerus b) -&gt; numerus {
        si a &gt; b { redde a }
        redde b
    }
}
</code></pre>
<p>Access static members through the type name:</p>
<pre><code class="language-fab">scribe Colores.ruber      # &quot;#FF0000&quot;
scribe Math.PI            # 3.14159
fixum m = Math.maximus(5, 3)  # 5
</code></pre>
<p>Static members are useful for constants, utility functions, and factory methods that don&#39;t require instance state.</p>
<h3 id="field-visibility">Field Visibility</h3>
<p>Fields in a <code>genus</code> are public by default, following struct semantics where data is meant to be accessed directly. For fields that should be encapsulated, use visibility annotations:</p>
<pre><code class="language-fab">genus Persona {
    textus nomen              # public (default)

    @ privatum
    numerus internaAetas      # private - only accessible within this genus
}
</code></pre>
<p>The <code>@ privatum</code> annotation marks a field as accessible only within the <code>genus</code> that declares it. The <code>@ protectum</code> annotation allows access from subtypes as well.</p>
<h3 id="method-visibility">Method Visibility</h3>
<p>Methods follow the same pattern:</p>
<pre><code class="language-fab">genus Processor {
    functio process() -&gt; textus {       # public (default)
        redde ego.auxilium()
    }

    @ privata
    functio auxilium() -&gt; textus {      # private helper
        redde &quot;internal work&quot;
    }
}
</code></pre>
<p>Note the grammatical agreement: <code>privatum</code> for fields (neuter), <code>privata</code> for methods (feminine, agreeing with <code>functio</code>).</p>
<h3 id="abstract-types">Abstract Types</h3>
<p>The <code>abstractus</code> modifier creates a type that cannot be instantiated directly. Abstract types define structure and behavior that subtypes must complete:</p>
<pre><code class="language-fab">abstractus genus Figura {
    @ abstracta
    functio area() -&gt; numerus
}
</code></pre>
<p>Methods marked with <code>@ abstracta</code> have no body; subtypes must provide the implementation.</p>
<h3 id="generics">Generics</h3>
<p>A <code>genus</code> can be parameterized with type variables:</p>
<pre><code class="language-fab">genus Capsa&lt;T&gt; {
    T valor

    functio accipe() -&gt; T {
        redde ego.valor
    }
}

fixum c = novum Capsa&lt;numerus&gt; { valor: 42 }
scribe c.accipe()  # 42
</code></pre>
<p>Multiple type parameters are comma-separated: <code>genus Pair&lt;K, V&gt; { ... }</code>.</p>
<hr>
<h2 id="pactum-interfaces">pactum (Interfaces)</h2>
<p>A <code>pactum</code> defines a contract: a set of method signatures that a type promises to implement. The word means &quot;agreement&quot; or &quot;pact&quot;, reflecting its role as a behavioral promise rather than a structural definition.</p>
<h3 id="declaration">Declaration</h3>
<p>A <code>pactum</code> declares method signatures without implementations:</p>
<pre><code class="language-fab">pactum Drawable {
    functio draw() -&gt; vacuum
}

pactum Iterabilis&lt;T&gt; {
    functio sequens() -&gt; T?
    functio habet() -&gt; bivalens
}
</code></pre>
<p>Unlike <code>genus</code>, a <code>pactum</code> cannot have fields or property requirements. It defines only what a type can <em>do</em>, not what it <em>has</em>. This constraint keeps interfaces focused on behavior.</p>
<h3 id="implementation-with-implet">Implementation with implet</h3>
<p>A <code>genus</code> fulfills a <code>pactum</code> using the <code>implet</code> keyword (Latin &quot;fulfills&quot;):</p>
<pre><code class="language-fab">genus Circle implet Drawable {
    numerus radius: 10

    functio draw() {
        scribe scriptum(&quot;Drawing circle with radius ยง&quot;, ego.radius)
    }
}

genus Square implet Drawable {
    numerus side: 5

    functio draw() {
        scribe scriptum(&quot;Drawing square with side ยง&quot;, ego.side)
    }
}
</code></pre>
<p>The implementing type must provide concrete implementations for all methods declared in the <code>pactum</code>. The compiler verifies this at compile time.</p>
<p>A type can implement multiple interfaces:</p>
<pre><code class="language-fab">genus Document implet Readable, Writable, Printable {
    # must implement methods from all three pactum
}
</code></pre>
<hr>
<h2 id="instantiation">Instantiation</h2>
<h3 id="creating-instances-with-novum">Creating Instances with novum</h3>
<p>The <code>novum</code> keyword creates a new instance of a <code>genus</code>. The word is Latin for &quot;new&quot;:</p>
<pre><code class="language-fab">fixum p = novum Punctum { x: 10, y: 20 }
</code></pre>
<p>Field values are provided in an object literal following the type name. Required fields (those without defaults) must be specified:</p>
<pre><code class="language-fab">genus Persona {
    textus nomen           # required - no default
    numerus aetas: 0       # optional - has default
}

# nomen is required, aetas is optional
fixum marcus = novum Persona { nomen: &quot;Marcus&quot; }
scribe marcus.aetas  # 0 (default)

# Override defaults by providing values
fixum julia = novum Persona { nomen: &quot;Julia&quot;, aetas: 25 }
</code></pre>
<p>When all fields have defaults, the literal can be omitted entirely:</p>
<pre><code class="language-fab">genus Counter {
    numerus count: 0
}

varia counter = novum Counter  # no braces needed
</code></pre>
<h3 id="construction-from-variables">Construction from Variables</h3>
<p>When constructing from an existing variable, use the <code>de</code> (from) preposition:</p>
<pre><code class="language-fab">fixum props = getPersonaProps()
fixum p = novum Persona de props
</code></pre>
<p>This merges the source object&#39;s fields into the new instance, following the same rules as literal construction.</p>
<h3 id="the-creo-hook">The creo() Hook</h3>
<p>The optional <code>creo()</code> method runs after construction is complete. Use it for validation, clamping values, or computing derived state:</p>
<pre><code class="language-fab">genus BoundedValue {
    numerus value: 0

    functio creo() {
        si ego.value &lt; 0 {
            ego.value = 0
        }
        si ego.value &gt; 100 {
            ego.value = 100
        }
    }
}
</code></pre>
<p>The initialization sequence is:</p>
<ol>
<li>Field defaults are applied</li>
<li>Literal overrides (or <code>de</code> source) are merged</li>
<li><code>creo()</code> runs if defined</li>
</ol>
<p>By the time <code>creo()</code> executes, <code>ego</code> already has all its field values. The method takes no parameters because everything it needs is already on the instance.</p>
<p>A practical use is computing derived fields:</p>
<pre><code class="language-fab">genus Circle {
    numerus radius: 1
    numerus diameter: 0
    numerus area: 0

    functio creo() {
        ego.diameter = ego.radius * 2
        ego.area = 3.14159 * ego.radius * ego.radius
    }
}

fixum c = novum Circle { radius: 5 }
scribe c.diameter  # 10
scribe c.area      # 78.54
</code></pre>
<p>Most types will not need <code>creo()</code>. The declarative field defaults handle the common case. Reserve <code>creo()</code> for invariants, validation, or derived initialization that cannot be expressed as simple defaults.</p>
<hr>
<h2 id="design-philosophy">Design Philosophy</h2>
<p>Faber&#39;s type system reflects several deliberate choices:</p>
<p><strong>Composition over inheritance.</strong> There is no <code>extends</code> keyword. Types compose behavior through <code>implet</code> and embed other types as fields. This avoids the fragility of deep inheritance hierarchies.</p>
<p><strong>Methods over getters.</strong> Faber omits computed properties (getters). Derived values use explicit methods: <code>r.area()</code> rather than <code>r.area</code>. The parentheses honestly communicate that computation is happening. Getters that start simple often grow complex, but their API is locked to property syntax.</p>
<p><strong>Struct semantics by default.</strong> Fields are public unless explicitly marked private. This transparency suits data-oriented design where types are containers of state rather than encapsulated black boxes.</p>
<p><strong>No classes, no constructors.</strong> The <code>genus</code> keyword names a type of thing, not a blueprint for objects. Construction happens through <code>novum</code> with declarative field specification, not imperative constructor logic.</p>
<p>These choices produce code that is explicit about data flow and honest about computation. The Roman craftsman built things to last; Faber aims for code that remains comprehensible as it evolves.</p>

    </main>
  </div>
</body>
</html>
