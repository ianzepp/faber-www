<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Grammar Reference - Faber</title>
  <meta name="description" content="Formal Faber language grammar in EBNF">
  <link rel="stylesheet" href="/styles.css">
  <link rel="alternate" type="text/plain" href="/llms.txt" title="LLM Site Index">
  <link rel="alternate" type="text/markdown" href="/faber-complete.md" title="Complete Documentation (Markdown)">
</head>
<body>
  <input type="checkbox" id="nav-toggle" class="nav-toggle">
  <header class="header">
    <div class="header-banner">Pre-alpha: Published for early evaluation only</div>
    <div class="header-bar">
      <a href="/" class="header-logo">Faber</a>
      <label for="nav-toggle" class="header-menu" aria-label="Toggle navigation">
        <span></span>
        <span></span>
        <span></span>
      </label>
    </div>
  </header>
  <div class="container">
    <nav class="site-nav">
  <div class="nav-section">compilers</div>
  <a href="/compilers/faber.html">Faber (Reference)</a>
  <a href="/compilers/rivus.html">Rivus (Bootstrap)</a>
  <div class="nav-section">research</div>
  <a href="/research/index.html">Thesis and Trials</a>
  <a href="/research/framework-1.1.html">Framework 1.1 Results</a>
  <div class="nav-section">docs</div>
  <a href="/docs/index.html">Documentation</a>
  <a href="/docs/grammar.html" class="active">Grammar Reference</a>
  <div class="nav-subheadings">
    <a href="/docs/grammar.html#program-structure">Program Structure</a>
    <a href="/docs/grammar.html#declarations">Declarations</a>
    <a href="/docs/grammar.html#variables" class="nav-h3">Variables</a>
    <a href="/docs/grammar.html#functions" class="nav-h3">Functions</a>
    <a href="/docs/grammar.html#classes" class="nav-h3">Classes</a>
    <a href="/docs/grammar.html#interfaces" class="nav-h3">Interfaces</a>
    <a href="/docs/grammar.html#type-aliases" class="nav-h3">Type Aliases</a>
    <a href="/docs/grammar.html#enums" class="nav-h3">Enums</a>
    <a href="/docs/grammar.html#tagged-unions" class="nav-h3">Tagged Unions</a>
    <a href="/docs/grammar.html#imports" class="nav-h3">Imports</a>
    <a href="/docs/grammar.html#types">Types</a>
    <a href="/docs/grammar.html#primitive-types" class="nav-h3">Primitive Types</a>
    <a href="/docs/grammar.html#generic-collections" class="nav-h3">Generic Collections</a>
    <a href="/docs/grammar.html#control-flow">Control Flow</a>
    <a href="/docs/grammar.html#conditionals" class="nav-h3">Conditionals</a>
    <a href="/docs/grammar.html#loops" class="nav-h3">Loops</a>
    <a href="/docs/grammar.html#switch-match" class="nav-h3">Switch/Match</a>
    <a href="/docs/grammar.html#pattern-matching" class="nav-h3">Pattern Matching</a>
    <a href="/docs/grammar.html#guards" class="nav-h3">Guards</a>
    <a href="/docs/grammar.html#resource-management" class="nav-h3">Resource Management</a>
    <a href="/docs/grammar.html#control-transfer" class="nav-h3">Control Transfer</a>
    <a href="/docs/grammar.html#error-handling">Error Handling</a>
    <a href="/docs/grammar.html#expressions">Expressions</a>
    <a href="/docs/grammar.html#operators-by-precedence-lowest-to-highest" class="nav-h3">Operators (by precedence, lowest to highest)</a>
    <a href="/docs/grammar.html#call-and-member-access" class="nav-h3">Call and Member Access</a>
    <a href="/docs/grammar.html#primary-expressions" class="nav-h3">Primary Expressions</a>
    <a href="/docs/grammar.html#special-expressions" class="nav-h3">Special Expressions</a>
    <a href="/docs/grammar.html#patterns">Patterns</a>
    <a href="/docs/grammar.html#output">Output</a>
    <a href="/docs/grammar.html#entry-points">Entry Points</a>
    <a href="/docs/grammar.html#testing">Testing</a>
    <a href="/docs/grammar.html#endpoint-dispatch">Endpoint Dispatch</a>
    <a href="/docs/grammar.html#dsl-transforms">DSL Transforms</a>
    <a href="/docs/grammar.html#fac-block">Fac Block</a>
    <a href="/docs/grammar.html#mutation-block">Mutation Block</a>
    <a href="/docs/grammar.html#keyword-reference">Keyword Reference</a>
    <a href="/docs/grammar.html#critical-syntax-rules">Critical Syntax Rules</a>
  </div>
  <a href="/docs/examples.html">Examples</a>
  <a href="/docs/examples-full.html">All Examples</a>
  <a href="/docs/fundamenta.html">Fundamenta</a>
  <a href="/docs/typi.html">Typi</a>
  <a href="/docs/operatores.html">Operatores</a>
  <a href="/docs/structurae.html">Structurae</a>
  <a href="/docs/regimen.html">Regimen</a>
  <a href="/docs/functiones.html">Functiones</a>
  <a href="/docs/importa.html">Importa</a>
  <a href="/docs/errores.html">Errores</a>
</nav>
    <main class="content">
      <h1 id="faber-language-specification">Faber Language Specification</h1>
<p>Formal grammar for the Faber programming language. This is the authoritative specification that both faber (TypeScript) and rivus (Faber) compilers implement.</p>
<hr>
<h2 id="program-structure">Program Structure</h2>
<pre><code class="language-ebnf">program     := statement*
statement   := importDecl | varDecl | funcDecl | genusDecl | pactumDecl
             | typeAliasDecl | enumDecl | discretioDecl
             | ifStmt | whileStmt | exStmt | deStmt | inStmt
             | eligeStmt | discerneStmt | guardStmt | curaStmt
             | tryStmt | returnStmt | breakStmt | continueStmt | throwStmt
             | assertStmt | outputStmt | adStmt | incipitStmt
             | probandumDecl | probaStmt | blockStmt | exprStmt
blockStmt   := &#39;{&#39; statement* &#39;}&#39;
</code></pre>
<hr>
<h2 id="declarations">Declarations</h2>
<h3 id="variables">Variables</h3>
<pre><code class="language-ebnf">varDecl      := (&#39;fixum&#39; | &#39;varia&#39; | &#39;figendum&#39; | &#39;variandum&#39;) typeAnnotation? IDENTIFIER (&#39;=&#39; expression)?
arrayDestruct := (&#39;fixum&#39; | &#39;varia&#39;) arrayPattern &#39;=&#39; expression
objectDestruct := (&#39;fixum&#39; | &#39;varia&#39;) objectPattern &#39;=&#39; expression
</code></pre>
<ul>
<li><code>fixum</code> = const, <code>varia</code> = let</li>
<li><code>figendum</code>/<code>variandum</code> = const/let with await</li>
</ul>
<h3 id="functions">Functions</h3>
<pre><code class="language-ebnf">funcDecl     := &#39;functio&#39; IDENTIFIER &#39;(&#39; paramList &#39;)&#39; funcModifier* returnClause? blockStmt
paramList    := (typeParamDecl &#39;,&#39;)* (parameter (&#39;,&#39; parameter)*)?
typeParamDecl := &#39;prae&#39; &#39;typus&#39; IDENTIFIER
parameter    := (&#39;de&#39; | &#39;in&#39; | &#39;ex&#39;)? &#39;si&#39;? &#39;ceteri&#39;? typeAnnotation? IDENTIFIER (&#39;ut&#39; IDENTIFIER)? (&#39;vel&#39; expression)?
funcModifier := &#39;futura&#39; | &#39;cursor&#39; | &#39;curata&#39; IDENTIFIER
returnClause := (&#39;-&gt;&#39; | &#39;fit&#39; | &#39;fiet&#39; | &#39;fiunt&#39; | &#39;fient&#39;) typeAnnotation
lambdaExpr   := (&#39;pro&#39; | &#39;fit&#39; | &#39;fiet&#39;) params? (&#39;-&gt;&#39; type)? (&#39;:&#39; expression | blockStmt)
</code></pre>
<ul>
<li>Return verbs: <code>fit</code> (sync), <code>fiet</code> (async), <code>fiunt</code> (generator), <code>fient</code> (async generator)</li>
<li>Parameter prefixes: <code>de</code> (read), <code>in</code> (mutate), <code>ex</code> (consume)</li>
<li><code>si</code> marks optional, <code>ceteri</code> marks rest parameter</li>
</ul>
<h3 id="classes">Classes</h3>
<pre><code class="language-ebnf">genusDecl    := &#39;abstractus&#39;? &#39;genus&#39; IDENTIFIER typeParams? (&#39;sub&#39; IDENTIFIER)? (&#39;implet&#39; IDENTIFIER (&#39;,&#39; IDENTIFIER)*)? &#39;{&#39; genusMember* &#39;}&#39;
genusMember  := annotation* (fieldDecl | methodDecl)
fieldDecl    := &#39;generis&#39;? &#39;nexum&#39;? typeAnnotation IDENTIFIER (&#39;:&#39; expression)?
methodDecl   := &#39;functio&#39; IDENTIFIER &#39;(&#39; paramList &#39;)&#39; funcModifier* returnClause? blockStmt?
annotation   := &#39;@&#39; IDENTIFIER+
</code></pre>
<ul>
<li><code>sub</code> = extends, <code>implet</code> = implements</li>
<li><code>generis</code> = static, <code>nexum</code> = bound/property</li>
</ul>
<h3 id="interfaces">Interfaces</h3>
<pre><code class="language-ebnf">pactumDecl   := &#39;pactum&#39; IDENTIFIER typeParams? &#39;{&#39; pactumMethod* &#39;}&#39;
pactumMethod := &#39;functio&#39; IDENTIFIER &#39;(&#39; paramList &#39;)&#39; funcModifier* returnClause?
</code></pre>
<h3 id="type-aliases">Type Aliases</h3>
<pre><code class="language-ebnf">typeAliasDecl := &#39;typus&#39; IDENTIFIER &#39;=&#39; typeAnnotation
</code></pre>
<h3 id="enums">Enums</h3>
<pre><code class="language-ebnf">enumDecl   := &#39;ordo&#39; IDENTIFIER &#39;{&#39; enumMember (&#39;,&#39; enumMember)* &#39;,&#39;? &#39;}&#39;
enumMember := IDENTIFIER (&#39;=&#39; (&#39;-&#39;? NUMBER | STRING))?
</code></pre>
<h3 id="tagged-unions">Tagged Unions</h3>
<pre><code class="language-ebnf">discretioDecl := &#39;discretio&#39; IDENTIFIER typeParams? &#39;{&#39; variant (&#39;,&#39; variant)* &#39;,&#39;? &#39;}&#39;
variant       := IDENTIFIER (&#39;{&#39; variantFields &#39;}&#39;)?
variantFields := (typeAnnotation IDENTIFIER (&#39;,&#39; typeAnnotation IDENTIFIER)*)?
</code></pre>
<h3 id="imports">Imports</h3>
<pre><code class="language-ebnf">importDecl    := &#39;ex&#39; (STRING | IDENTIFIER) &#39;importa&#39; (specifierList | &#39;*&#39;)
specifierList := specifier (&#39;,&#39; specifier)*
specifier     := IDENTIFIER (&#39;ut&#39; IDENTIFIER)?
</code></pre>
<hr>
<h2 id="types">Types</h2>
<pre><code class="language-ebnf">typeAnnotation := (&#39;de&#39; | &#39;in&#39;)? IDENTIFIER typeParams? &#39;?&#39;? arrayBrackets*
typeParams     := &#39;&lt;&#39; typeParameter (&#39;,&#39; typeParameter)* &#39;&gt;&#39;
typeParameter  := typeAnnotation | NUMBER | MODIFIER
arrayBrackets  := &#39;[]&#39; &#39;?&#39;?
</code></pre>
<h3 id="primitive-types">Primitive Types</h3>
<table>
<thead>
<tr>
<th>Faber</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td><code>textus</code></td>
<td>string</td>
</tr>
<tr>
<td><code>numerus</code></td>
<td>integer</td>
</tr>
<tr>
<td><code>fractus</code></td>
<td>float</td>
</tr>
<tr>
<td><code>bivalens</code></td>
<td>boolean</td>
</tr>
<tr>
<td><code>nihil</code></td>
<td>null</td>
</tr>
<tr>
<td><code>vacuum</code></td>
<td>void</td>
</tr>
<tr>
<td><code>numquam</code></td>
<td>never</td>
</tr>
<tr>
<td><code>ignotum</code></td>
<td>unknown</td>
</tr>
<tr>
<td><code>octeti</code></td>
<td>bytes</td>
</tr>
</tbody></table>
<h3 id="generic-collections">Generic Collections</h3>
<table>
<thead>
<tr>
<th>Faber</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td><code>lista&lt;T&gt;</code></td>
<td>array</td>
</tr>
<tr>
<td><code>tabula&lt;K,V&gt;</code></td>
<td>map</td>
</tr>
<tr>
<td><code>copia&lt;T&gt;</code></td>
<td>set</td>
</tr>
<tr>
<td><code>promissum&lt;T&gt;</code></td>
<td>promise</td>
</tr>
<tr>
<td><code>cursor&lt;T&gt;</code></td>
<td>iterator</td>
</tr>
<tr>
<td><code>unio&lt;A,B&gt;</code></td>
<td>union</td>
</tr>
</tbody></table>
<hr>
<h2 id="control-flow">Control Flow</h2>
<h3 id="conditionals">Conditionals</h3>
<pre><code class="language-ebnf">ifStmt     := &#39;si&#39; expression (blockStmt | &#39;ergo&#39; statement | &#39;reddit&#39; expression)
              (&#39;cape&#39; IDENTIFIER blockStmt)? (elseClause | &#39;sin&#39; ifStmt)?
elseClause := &#39;secus&#39; (ifStmt | blockStmt | statement)
</code></pre>
<ul>
<li><code>si</code> = if, <code>sin</code> = else-if, <code>secus</code> = else</li>
<li><code>ergo</code> for one-liners, <code>reddit</code> for early return</li>
</ul>
<h3 id="loops">Loops</h3>
<pre><code class="language-ebnf">whileStmt := &#39;dum&#39; expression (blockStmt | &#39;ergo&#39; statement | &#39;reddit&#39; expression) (&#39;cape&#39; IDENTIFIER blockStmt)?
exStmt    := &#39;ex&#39; expression (forBinding | destructBinding)
forBinding := (&#39;pro&#39; | &#39;fit&#39; | &#39;fiet&#39;) IDENTIFIER (blockStmt | &#39;ergo&#39; statement | &#39;reddit&#39; expression) catchClause?
deStmt    := &#39;de&#39; expression (&#39;pro&#39; | &#39;fit&#39; | &#39;fiet&#39;) IDENTIFIER (blockStmt | &#39;ergo&#39; statement) catchClause?
</code></pre>
<ul>
<li><code>dum</code> = while</li>
<li><code>ex...pro</code> = for-of (values)</li>
<li><code>de...pro</code> = for-in (keys)</li>
</ul>
<h3 id="switch-match">Switch/Match</h3>
<pre><code class="language-ebnf">eligeStmt    := &#39;elige&#39; expression &#39;{&#39; eligeCase* defaultCase? &#39;}&#39; catchClause?
eligeCase    := &#39;casu&#39; expression (blockStmt | &#39;ergo&#39; statement | &#39;reddit&#39; expression)
defaultCase  := &#39;ceterum&#39; (blockStmt | statement)
</code></pre>
<h3 id="pattern-matching">Pattern Matching</h3>
<pre><code class="language-ebnf">discerneStmt := &#39;discerne&#39; discriminants &#39;{&#39; variantCase* &#39;}&#39;
discriminants := expression (&#39;,&#39; expression)*
variantCase  := &#39;casu&#39; patterns (blockStmt | &#39;ergo&#39; statement | &#39;reddit&#39; expression)
patterns     := pattern (&#39;,&#39; pattern)*
pattern      := &#39;_&#39; | (IDENTIFIER patternBind?)
patternBind  := (&#39;ut&#39; IDENTIFIER) | (&#39;pro&#39; IDENTIFIER (&#39;,&#39; IDENTIFIER)*)
</code></pre>
<h3 id="guards">Guards</h3>
<pre><code class="language-ebnf">guardStmt   := &#39;custodi&#39; &#39;{&#39; guardClause+ &#39;}&#39;
guardClause := &#39;si&#39; expression (blockStmt | &#39;ergo&#39; statement | &#39;reddit&#39; expression)
</code></pre>
<h3 id="resource-management">Resource Management</h3>
<pre><code class="language-ebnf">curaStmt    := &#39;cura&#39; curatorKind? expression? (&#39;pro&#39; | &#39;fit&#39; | &#39;fiet&#39;) typeAnnotation? IDENTIFIER blockStmt catchClause?
curatorKind := &#39;arena&#39; | &#39;page&#39;
</code></pre>
<h3 id="control-transfer">Control Transfer</h3>
<pre><code class="language-ebnf">returnStmt   := &#39;redde&#39; expression?
breakStmt    := &#39;rumpe&#39;
continueStmt := &#39;perge&#39;
</code></pre>
<hr>
<h2 id="error-handling">Error Handling</h2>
<pre><code class="language-ebnf">tryStmt     := &#39;tempta&#39; blockStmt (&#39;cape&#39; IDENTIFIER blockStmt)? (&#39;demum&#39; blockStmt)?
throwStmt   := (&#39;iace&#39; | &#39;mori&#39;) expression
catchClause := &#39;cape&#39; IDENTIFIER blockStmt
assertStmt  := &#39;adfirma&#39; expression (&#39;,&#39; expression)?
</code></pre>
<ul>
<li><code>tempta</code> = try, <code>cape</code> = catch, <code>demum</code> = finally</li>
<li><code>iace</code> = throw (recoverable), <code>mori</code> = panic (fatal)</li>
</ul>
<hr>
<h2 id="expressions">Expressions</h2>
<h3 id="operators-by-precedence-lowest-to-highest">Operators (by precedence, lowest to highest)</h3>
<pre><code class="language-ebnf">expression := assignment
assignment := ternary ((&#39;=&#39; | &#39;+=&#39; | &#39;-=&#39; | &#39;*=&#39; | &#39;/=&#39; | &#39;&amp;=&#39; | &#39;|=&#39;) assignment)?
ternary    := or ((&#39;?&#39; expression &#39;:&#39; | &#39;sic&#39; expression &#39;secus&#39;) ternary)?
or         := and ((&#39;||&#39; | &#39;aut&#39;) and)* | and (&#39;vel&#39; and)*
and        := equality ((&#39;&amp;&amp;&#39; | &#39;et&#39;) equality)*
equality   := comparison ((&#39;==&#39; | &#39;!=&#39; | &#39;===&#39; | &#39;!==&#39; | &#39;est&#39; | &#39;non&#39; &#39;est&#39;) comparison)*
comparison := bitwiseOr ((&#39;&lt;&#39; | &#39;&gt;&#39; | &#39;&lt;=&#39; | &#39;&gt;=&#39; | &#39;intra&#39; | &#39;inter&#39;) bitwiseOr)*
bitwiseOr  := bitwiseXor (&#39;|&#39; bitwiseXor)*
bitwiseXor := bitwiseAnd (&#39;^&#39; bitwiseAnd)*
bitwiseAnd := shift (&#39;&amp;&#39; shift)*
shift      := range ((&#39;&lt;&lt;&#39; | &#39;&gt;&gt;&#39;) range)*
range      := additive ((&#39;..&#39; | &#39;ante&#39; | &#39;usque&#39;) additive (&#39;per&#39; additive)?)?
additive   := multiplicative ((&#39;+&#39; | &#39;-&#39;) multiplicative)*
multiplicative := unary ((&#39;*&#39; | &#39;/&#39; | &#39;%&#39;) unary)*
unary      := (&#39;!&#39; | &#39;-&#39; | &#39;non&#39; | &#39;nulla&#39; | &#39;nonnulla&#39; | &#39;nihil&#39; | &#39;nonnihil&#39; | &#39;negativum&#39; | &#39;positivum&#39; | &#39;cede&#39; | &#39;novum&#39; | &#39;finge&#39;) unary | cast
cast       := call (&#39;qua&#39; typeAnnotation | &#39;innatum&#39; typeAnnotation)*
</code></pre>
<h3 id="call-and-member-access">Call and Member Access</h3>
<pre><code class="language-ebnf">call          := primary (callSuffix | memberSuffix | optionalSuffix | nonNullSuffix)*
callSuffix    := &#39;(&#39; argumentList &#39;)&#39;
memberSuffix  := &#39;.&#39; IDENTIFIER | &#39;[&#39; expression &#39;]&#39;
optionalSuffix := &#39;?.&#39; IDENTIFIER | &#39;?[&#39; expression &#39;]&#39; | &#39;?(&#39; argumentList &#39;)&#39;
nonNullSuffix := &#39;!.&#39; IDENTIFIER | &#39;![&#39; expression &#39;]&#39; | &#39;!(&#39; argumentList &#39;)&#39;
argumentList  := (argument (&#39;,&#39; argument)*)?
argument      := &#39;sparge&#39;? expression
</code></pre>
<h3 id="primary-expressions">Primary Expressions</h3>
<pre><code class="language-ebnf">primary := IDENTIFIER | NUMBER | STRING | TEMPLATE_STRING
         | &#39;ego&#39; | &#39;verum&#39; | &#39;falsum&#39; | &#39;nihil&#39;
         | arrayLiteral | objectLiteral
         | &#39;(&#39; expression &#39;)&#39;
</code></pre>
<h3 id="special-expressions">Special Expressions</h3>
<pre><code class="language-ebnf">newExpr       := &#39;novum&#39; IDENTIFIER (&#39;(&#39; argumentList &#39;)&#39;)? (objectLiteral | &#39;de&#39; expression)?
fingeExpr     := &#39;finge&#39; IDENTIFIER (&#39;{&#39; fieldList &#39;}&#39;)? (&#39;qua&#39; IDENTIFIER)?
praefixumExpr := &#39;praefixum&#39; (blockStmt | &#39;(&#39; expression &#39;)&#39;)
scriptumExpr  := &#39;scriptum&#39; &#39;(&#39; STRING (&#39;,&#39; expression)* &#39;)&#39;
legeExpr      := &#39;lege&#39; &#39;lineam&#39;?
regexLiteral  := &#39;sed&#39; STRING IDENTIFIER?
</code></pre>
<hr>
<h2 id="patterns">Patterns</h2>
<pre><code class="language-ebnf">objectPattern  := &#39;{&#39; patternProperty (&#39;,&#39; patternProperty)* &#39;}&#39;
patternProperty := &#39;ceteri&#39;? IDENTIFIER (&#39;:&#39; IDENTIFIER)?
arrayPattern   := &#39;[&#39; arrayPatternElement (&#39;,&#39; arrayPatternElement)* &#39;]&#39;
arrayPatternElement := &#39;_&#39; | &#39;ceteri&#39;? IDENTIFIER
</code></pre>
<hr>
<h2 id="output">Output</h2>
<pre><code class="language-ebnf">outputStmt := (&#39;scribe&#39; | &#39;vide&#39; | &#39;mone&#39;) expression (&#39;,&#39; expression)*
</code></pre>
<ul>
<li><code>scribe</code> = log, <code>vide</code> = debug, <code>mone</code> = warn</li>
</ul>
<hr>
<h2 id="entry-points">Entry Points</h2>
<pre><code class="language-ebnf">incipitStmt  := &#39;incipit&#39; (blockStmt | &#39;ergo&#39; statement | &#39;reddit&#39; expression)
incipietStmt := &#39;incipiet&#39; (blockStmt | &#39;ergo&#39; statement | &#39;reddit&#39; expression)
</code></pre>
<ul>
<li><code>incipit</code> = sync entry, <code>incipiet</code> = async entry</li>
</ul>
<hr>
<h2 id="testing">Testing</h2>
<pre><code class="language-ebnf">probandumDecl := &#39;probandum&#39; STRING &#39;{&#39; probandumBody &#39;}&#39;
probandumBody := (praeparaBlock | probandumDecl | probaStmt)*
probaStmt     := &#39;proba&#39; probaModifier? STRING blockStmt
probaModifier := &#39;omitte&#39; STRING | &#39;futurum&#39; STRING
praeparaBlock := (&#39;praepara&#39; | &#39;praeparabit&#39; | &#39;postpara&#39; | &#39;postparabit&#39;) &#39;omnia&#39;? blockStmt
</code></pre>
<hr>
<h2 id="endpoint-dispatch">Endpoint Dispatch</h2>
<pre><code class="language-ebnf">adStmt        := &#39;ad&#39; STRING &#39;(&#39; argumentList &#39;)&#39; adBinding? blockStmt? catchClause?
adBinding     := adBindingVerb typeAnnotation? &#39;pro&#39; IDENTIFIER (&#39;ut&#39; IDENTIFIER)?
adBindingVerb := &#39;fit&#39; | &#39;fiet&#39; | &#39;fiunt&#39; | &#39;fient&#39;
</code></pre>
<hr>
<h2 id="dsl-transforms">DSL Transforms</h2>
<pre><code class="language-ebnf">dslExpr      := &#39;ex&#39; expression dslTransforms
dslTransforms := dslTransform (&#39;,&#39; dslTransform)*
dslTransform := dslVerb expression?
dslVerb      := &#39;prima&#39; | &#39;ultima&#39; | &#39;summa&#39;

abExpr := &#39;ab&#39; expression filter? (&#39;,&#39; dslTransform)*
filter := &#39;non&#39;? (&#39;ubi&#39; condition | IDENTIFIER)
</code></pre>
<hr>
<h2 id="fac-block">Fac Block</h2>
<pre><code class="language-ebnf">facBlockStmt := &#39;fac&#39; blockStmt (&#39;cape&#39; IDENTIFIER blockStmt)? (&#39;dum&#39; expression)?
</code></pre>
<ul>
<li>Creates scope, optionally with catch or do-while</li>
</ul>
<hr>
<h2 id="mutation-block">Mutation Block</h2>
<pre><code class="language-ebnf">inStmt := &#39;in&#39; expression blockStmt
</code></pre>
<hr>
<h2 id="keyword-reference">Keyword Reference</h2>
<table>
<thead>
<tr>
<th>Category</th>
<th>Faber</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Declarations</strong></td>
<td><code>fixum</code></td>
<td>const</td>
</tr>
<tr>
<td></td>
<td><code>varia</code></td>
<td>let</td>
</tr>
<tr>
<td></td>
<td><code>functio</code></td>
<td>function</td>
</tr>
<tr>
<td></td>
<td><code>genus</code></td>
<td>class</td>
</tr>
<tr>
<td></td>
<td><code>pactum</code></td>
<td>interface</td>
</tr>
<tr>
<td></td>
<td><code>typus</code></td>
<td>type alias</td>
</tr>
<tr>
<td></td>
<td><code>ordo</code></td>
<td>enum</td>
</tr>
<tr>
<td></td>
<td><code>discretio</code></td>
<td>tagged union</td>
</tr>
<tr>
<td><strong>Control Flow</strong></td>
<td><code>si</code> / <code>sin</code> / <code>secus</code></td>
<td>if / else-if / else</td>
</tr>
<tr>
<td></td>
<td><code>dum</code></td>
<td>while</td>
</tr>
<tr>
<td></td>
<td><code>ex...pro</code></td>
<td>for-of</td>
</tr>
<tr>
<td></td>
<td><code>de...pro</code></td>
<td>for-in</td>
</tr>
<tr>
<td></td>
<td><code>elige</code> / <code>casu</code></td>
<td>switch / case</td>
</tr>
<tr>
<td></td>
<td><code>discerne</code></td>
<td>pattern match</td>
</tr>
<tr>
<td></td>
<td><code>custodi</code></td>
<td>guard</td>
</tr>
<tr>
<td></td>
<td><code>redde</code></td>
<td>return</td>
</tr>
<tr>
<td></td>
<td><code>rumpe</code></td>
<td>break</td>
</tr>
<tr>
<td></td>
<td><code>perge</code></td>
<td>continue</td>
</tr>
<tr>
<td><strong>Error Handling</strong></td>
<td><code>tempta</code></td>
<td>try</td>
</tr>
<tr>
<td></td>
<td><code>cape</code></td>
<td>catch</td>
</tr>
<tr>
<td></td>
<td><code>demum</code></td>
<td>finally</td>
</tr>
<tr>
<td></td>
<td><code>iace</code></td>
<td>throw</td>
</tr>
<tr>
<td></td>
<td><code>mori</code></td>
<td>panic</td>
</tr>
<tr>
<td></td>
<td><code>adfirma</code></td>
<td>assert</td>
</tr>
<tr>
<td><strong>Async</strong></td>
<td><code>futura</code></td>
<td>async modifier</td>
</tr>
<tr>
<td></td>
<td><code>cede</code></td>
<td>await</td>
</tr>
<tr>
<td><strong>Boolean</strong></td>
<td><code>verum</code></td>
<td>true</td>
</tr>
<tr>
<td></td>
<td><code>falsum</code></td>
<td>false</td>
</tr>
<tr>
<td></td>
<td><code>et</code></td>
<td>and</td>
</tr>
<tr>
<td></td>
<td><code>aut</code></td>
<td>or</td>
</tr>
<tr>
<td></td>
<td><code>non</code></td>
<td>not</td>
</tr>
<tr>
<td></td>
<td><code>vel</code></td>
<td>nullish coalescing</td>
</tr>
<tr>
<td><strong>Objects</strong></td>
<td><code>ego</code></td>
<td>this/self</td>
</tr>
<tr>
<td></td>
<td><code>novum</code></td>
<td>new</td>
</tr>
<tr>
<td></td>
<td><code>finge</code></td>
<td>construct variant</td>
</tr>
<tr>
<td><strong>Output</strong></td>
<td><code>scribe</code></td>
<td>log</td>
</tr>
<tr>
<td></td>
<td><code>vide</code></td>
<td>debug</td>
</tr>
<tr>
<td></td>
<td><code>mone</code></td>
<td>warn</td>
</tr>
</tbody></table>
<hr>
<h2 id="critical-syntax-rules">Critical Syntax Rules</h2>
<ol>
<li><strong>Type-first parameters</strong>: <code>functio f(numerus x)</code> NOT <code>functio f(x: numerus)</code></li>
<li><strong>Type-first declarations</strong>: <code>fixum textus name</code> NOT <code>fixum name: textus</code></li>
<li><strong>For-of loops</strong>: <code>ex collection pro item { }</code> (collection first)</li>
<li><strong>Parentheses around conditions are valid but not idiomatic</strong>: prefer <code>si x &gt; 0 { }</code> or <code>si positivum x { }</code> over <code>si (x &gt; 0) { }</code></li>
<li><strong>Output keywords are statements</strong>, not functions â€” <code>scribe x</code> works, <code>scribe(x)</code> also works (parentheses group the expression), but <code>scribe</code> is not a callable value</li>
</ol>

    </main>
  </div>
  <footer class="footer-bar">
    <a href="https://github.com/ianzepp/faber-romanus" target="_blank" rel="noopener">
      <svg viewBox="0 0 16 16" width="18" height="18" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg>
      Visit or star on GitHub!
    </a>
  </footer>
</body>
</html>
