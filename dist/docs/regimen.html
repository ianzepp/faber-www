<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Regimen - Faber</title>
  <meta name="description" content="Faber programming language documentation">
  <link rel="stylesheet" href="/styles.css">
  <link rel="alternate" type="text/plain" href="/llms.txt" title="LLM Site Index">
  <link rel="alternate" type="text/markdown" href="/faber-complete.md" title="Complete Documentation (Markdown)">
</head>
<body>
  <input type="checkbox" id="nav-toggle" class="nav-toggle">
  <header class="header">
    <div class="header-banner">Pre-alpha: Published for early evaluation only</div>
    <div class="header-bar">
      <a href="/" class="header-logo">Faber</a>
      <label for="nav-toggle" class="header-menu" aria-label="Toggle navigation">
        <span></span>
        <span></span>
        <span></span>
      </label>
    </div>
  </header>
  <div class="container">
    <nav class="site-nav">
  <div class="nav-section">compilers</div>
  <a href="/compilers/faber.html">Faber (Reference)</a>
  <a href="/compilers/rivus.html">Rivus (Bootstrap)</a>
  <div class="nav-section">research</div>
  <a href="/research/index.html">Thesis and Trials</a>
  <a href="/research/framework-1.1.html">Framework 1.1 Results</a>
  <div class="nav-section">docs</div>
  <a href="/docs/index.html">Documentation</a>
  <a href="/docs/grammar.html">Grammar Reference</a>
  <a href="/docs/examples.html">Examples</a>
  <a href="/docs/examples-full.html">All Examples</a>
  <a href="/docs/fundamenta.html">Fundamenta</a>
  <a href="/docs/typi.html">Typi</a>
  <a href="/docs/operatores.html">Operatores</a>
  <a href="/docs/structurae.html">Structurae</a>
  <a href="/docs/regimen.html" class="active">Regimen</a>
  <div class="nav-subheadings">
    <a href="/docs/regimen.html#conditionals">Conditionals</a>
    <a href="/docs/regimen.html#si-if" class="nav-h3">si (If)</a>
    <a href="/docs/regimen.html#sin-else-if" class="nav-h3">sin (Else If)</a>
    <a href="/docs/regimen.html#secus-else" class="nav-h3">secus (Else)</a>
    <a href="/docs/regimen.html#short-forms" class="nav-h3">Short Forms</a>
    <a href="/docs/regimen.html#loops">Loops</a>
    <a href="/docs/regimen.html#dum-while" class="nav-h3">dum (While)</a>
    <a href="/docs/regimen.html#ex-pro-for-each-values" class="nav-h3">ex...pro (For Each Values)</a>
    <a href="/docs/regimen.html#de-pro-for-each-keys" class="nav-h3">de...pro (For Each Keys)</a>
    <a href="/docs/regimen.html#async-iteration" class="nav-h3">Async Iteration</a>
    <a href="/docs/regimen.html#loop-control" class="nav-h3">Loop Control</a>
    <a href="/docs/regimen.html#branching">Branching</a>
    <a href="/docs/regimen.html#elige-switch" class="nav-h3">elige (Switch)</a>
    <a href="/docs/regimen.html#discerne-pattern-match" class="nav-h3">discerne (Pattern Match)</a>
    <a href="/docs/regimen.html#guards-and-assertions">Guards and Assertions</a>
    <a href="/docs/regimen.html#custodi-guard-block" class="nav-h3">custodi (Guard Block)</a>
    <a href="/docs/regimen.html#adfirma-assert" class="nav-h3">adfirma (Assert)</a>
    <a href="/docs/regimen.html#summary">Summary</a>
  </div>
  <a href="/docs/functiones.html">Functiones</a>
  <a href="/docs/importa.html">Importa</a>
  <a href="/docs/errores.html">Errores</a>
</nav>
    <main class="content">
      <h1 id="regimen">Regimen</h1>
<p>Control flow determines how a program executes: which statements run, in what order, and under what conditions. Faber uses Latin keywords that map intuitively to their English equivalents while reading naturally as Latin prose.</p>
<p>The Latin word <em>regimen</em> means &quot;guidance&quot; or &quot;direction&quot;—literally, the act of steering. In Faber, control flow keywords <em>steer</em> execution through conditionals, loops, and branching constructs.</p>
<hr>
<h2 id="conditionals">Conditionals</h2>
<p>Conditional statements execute code based on whether a condition evaluates to true or false.</p>
<h3 id="si-if">si (If)</h3>
<p>The keyword <code>si</code> means &quot;if&quot; in Latin. It introduces a condition that, when true, executes the following block.</p>
<pre><code class="language-fab">si x &gt; 0 {
    scribe &quot;positive&quot;
}
</code></pre>
<p>The condition must be a boolean expression. If it evaluates to <code>verum</code> (true), the block executes. Otherwise, execution continues past the block.</p>
<p>Multiple statements can appear within the block:</p>
<pre><code class="language-fab">si user.authenticated {
    scribe &quot;Welcome back&quot;
    loadUserPreferences(user)
    updateLastLogin(user)
}
</code></pre>
<h3 id="sin-else-if">sin (Else If)</h3>
<p>The keyword <code>sin</code> is a classical Latin contraction of <code>si non</code>—&quot;but if&quot; or &quot;if however.&quot; It chains additional conditions after an initial <code>si</code>.</p>
<pre><code class="language-fab">fixum hour = 14

si hour &lt; 6 {
    scribe &quot;Late night&quot;
}
sin hour &lt; 12 {
    scribe &quot;Morning&quot;
}
sin hour &lt; 18 {
    scribe &quot;Afternoon&quot;
}
sin hour &lt; 22 {
    scribe &quot;Evening&quot;
}
</code></pre>
<p>Each <code>sin</code> condition is tested only if all preceding conditions were false. The chain stops at the first true condition.</p>
<h3 id="secus-else">secus (Else)</h3>
<p>The keyword <code>secus</code> means &quot;otherwise&quot; in Latin. It provides a default branch when no preceding condition matched.</p>
<pre><code class="language-fab">si hour &lt; 12 {
    scribe &quot;Morning&quot;
}
sin hour &lt; 18 {
    scribe &quot;Afternoon&quot;
}
secus {
    scribe &quot;Evening or night&quot;
}
</code></pre>
<p>A <code>secus</code> block always executes if reached—it has no condition to test. It must appear last in a conditional chain.</p>
<h3 id="short-forms">Short Forms</h3>
<p>Faber provides concise syntax for simple conditionals.</p>
<h4 id="ergo-therefore">ergo (Therefore)</h4>
<p>The keyword <code>ergo</code> means &quot;therefore&quot; or &quot;thus&quot; in Latin—expressing logical consequence. Use it for one-liner conditionals where a block would be verbose.</p>
<pre><code class="language-fab">si x &gt; 5 ergo scribe &quot;x is big&quot;
</code></pre>
<p>This is equivalent to:</p>
<pre><code class="language-fab">si x &gt; 5 {
    scribe &quot;x is big&quot;
}
</code></pre>
<p>The <code>ergo</code> form works with <code>secus</code> for one-liner if-else:</p>
<pre><code class="language-fab">si age &gt;= 18 ergo scribe &quot;Adult&quot; secus scribe &quot;Minor&quot;
</code></pre>
<h4 id="reddit-early-return">reddit (Early Return)</h4>
<p>The keyword <code>reddit</code> means &quot;it returns&quot; in Latin (third person singular of <em>reddere</em>, &quot;to give back&quot;). It combines <code>ergo</code> with <code>redde</code> for early return patterns.</p>
<pre><code class="language-fab">functio classify(numerus x) -&gt; textus {
    si x &lt; 0 reddit &quot;negative&quot;
    si x == 0 reddit &quot;zero&quot;
    redde &quot;positive&quot;
}
</code></pre>
<p>This is equivalent to:</p>
<pre><code class="language-fab">functio classify(numerus x) -&gt; textus {
    si x &lt; 0 {
        redde &quot;negative&quot;
    }
    si x == 0 {
        redde &quot;zero&quot;
    }
    redde &quot;positive&quot;
}
</code></pre>
<p>The <code>reddit</code> form excels at guard clauses—conditions that validate input and exit early:</p>
<pre><code class="language-fab">functio divide(numerus a, numerus b) -&gt; numerus? {
    si b == 0 reddit nihil
    redde a / b
}
</code></pre>
<p>It works throughout a conditional chain:</p>
<pre><code class="language-fab">functio grade(numerus score) -&gt; textus {
    si score &gt;= 90 reddit &quot;A&quot;
    sin score &gt;= 80 reddit &quot;B&quot;
    sin score &gt;= 70 reddit &quot;C&quot;
    sin score &gt;= 60 reddit &quot;D&quot;
    secus reddit &quot;F&quot;
}
</code></pre>
<hr>
<h2 id="loops">Loops</h2>
<p>Loops repeat a block of code, either a fixed number of times or until a condition changes.</p>
<h3 id="dum-while">dum (While)</h3>
<p>The keyword <code>dum</code> means &quot;while&quot; or &quot;as long as&quot; in Latin. It executes a block repeatedly while a condition remains true.</p>
<pre><code class="language-fab">varia numerus counter = 0

dum counter &lt; 5 {
    scribe counter
    counter = counter + 1
}
</code></pre>
<p>The condition is checked before each iteration. If it starts false, the block never executes.</p>
<p>While loops work well for countdown patterns:</p>
<pre><code class="language-fab">varia numerus countdown = 3

dum countdown &gt; 0 {
    scribe &quot;Countdown:&quot;, countdown
    countdown = countdown - 1
}
scribe &quot;Done!&quot;
</code></pre>
<p>The one-liner form uses <code>ergo</code>:</p>
<pre><code class="language-fab">dum i &gt; 0 ergo i = i - 1
</code></pre>
<h3 id="ex-pro-for-each-values">ex...pro (For Each Values)</h3>
<p>The <code>ex...pro</code> construct iterates over values in a collection. The syntax reads naturally in Latin: &quot;from items, for each item.&quot;</p>
<pre><code class="language-fab">fixum numbers = [1, 2, 3, 4, 5]

ex numbers pro n {
    scribe n
}
</code></pre>
<p>The Latin preposition <code>ex</code> means &quot;from&quot; or &quot;out of&quot;—the source from which values are drawn. The preposition <code>pro</code> means &quot;for&quot; or &quot;on behalf of&quot;—introducing the binding for each iteration.</p>
<p>This source-first syntax differs from most programming languages. Where JavaScript writes <code>for (const item of items)</code>, Faber writes <code>ex items pro item</code>. The Faber form mirrors natural language: &quot;from the list, for each element, do this.&quot;</p>
<p>The syntax works with any iterable:</p>
<pre><code class="language-fab">fixum names = [&quot;Marcus&quot;, &quot;Julia&quot;, &quot;Claudia&quot;]

ex names pro name {
    scribe name
}
</code></pre>
<p>Processing each item:</p>
<pre><code class="language-fab">fixum values = [10, 20, 30]

ex values pro v {
    fixum doubled = v * 2
    scribe doubled
}
</code></pre>
<p>The one-liner form:</p>
<pre><code class="language-fab">ex numbers pro n ergo scribe n
</code></pre>
<h4 id="range-expressions">Range Expressions</h4>
<p>Ranges generate sequences of numbers. Faber provides three range operators:</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Latin Meaning</th>
<th>End Behavior</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td><code>..</code></td>
<td>(shorthand)</td>
<td>exclusive</td>
<td><code>0..5</code> yields 0, 1, 2, 3, 4</td>
</tr>
<tr>
<td><code>ante</code></td>
<td>&quot;before&quot;</td>
<td>exclusive</td>
<td><code>0 ante 5</code> yields 0, 1, 2, 3, 4</td>
</tr>
<tr>
<td><code>usque</code></td>
<td>&quot;up to&quot;</td>
<td>inclusive</td>
<td><code>0 usque 5</code> yields 0, 1, 2, 3, 4, 5</td>
</tr>
</tbody></table>
<p>The <code>..</code> operator is convenient shorthand matching common programming conventions (Python&#39;s <code>range()</code>, Rust&#39;s <code>..</code>):</p>
<pre><code class="language-fab">ex 0..5 pro i {
    scribe i
}
</code></pre>
<p>The <code>ante</code> keyword makes exclusivity explicit—the range stops <em>before</em> the end value:</p>
<pre><code class="language-fab">ex 0 ante 5 pro i {
    scribe i
}
</code></pre>
<p>The <code>usque</code> keyword includes the end value—the range goes <em>up to and including</em> the end:</p>
<pre><code class="language-fab">ex 0 usque 5 pro i {
    scribe i
}
</code></pre>
<p>For step increments, use <code>per</code>:</p>
<pre><code class="language-fab">ex 0..10 per 2 pro i {
    scribe i  # 0, 2, 4, 6, 8
}

ex 0 usque 10 per 2 pro i {
    scribe i  # 0, 2, 4, 6, 8, 10
}
</code></pre>
<h3 id="de-pro-for-each-keys">de...pro (For Each Keys)</h3>
<p>The <code>de...pro</code> construct iterates over keys (property names or indices) rather than values. The syntax reads: &quot;concerning the object, for each key.&quot;</p>
<pre><code class="language-fab">fixum persona = { nomen: &quot;Marcus&quot;, aetas: 30, urbs: &quot;Roma&quot; }

de persona pro clavis {
    scribe clavis
}
</code></pre>
<p>The Latin preposition <code>de</code> means &quot;from&quot; or &quot;concerning&quot;—indicating a read-only relationship with the object. You&#39;re iterating <em>concerning</em> the object&#39;s structure, not extracting its contents.</p>
<p>To access values, use the key with bracket notation:</p>
<pre><code class="language-fab">de persona pro clavis {
    scribe scriptum(&quot;Key: §, Value: §&quot;, clavis, persona[clavis])
}
</code></pre>
<p>For arrays, <code>de</code> iterates indices:</p>
<pre><code class="language-fab">fixum numeri = [10, 20, 30]

de numeri pro index {
    scribe scriptum(&quot;Index §: §&quot;, index, numeri[index])
}
</code></pre>
<p>The distinction between <code>ex</code> and <code>de</code> mirrors their Latin meanings:</p>
<ul>
<li><code>ex items pro item</code> — draw <em>values</em> <strong>from</strong> the collection</li>
<li><code>de object pro key</code> — inspect <em>keys</em> <strong>concerning</strong> the object</li>
</ul>
<h3 id="async-iteration">Async Iteration</h3>
<p>For asynchronous streams, replace <code>pro</code> with <code>fiet</code> (&quot;it will become&quot;):</p>
<pre><code class="language-fab">ex stream fiet chunk {
    scribe chunk
}
</code></pre>
<p>The verb <code>fiet</code> is the future tense of <code>fio</code> (&quot;to become&quot;). It signals that each iteration awaits the next value—the chunk &quot;will become&quot; available.</p>
<table>
<thead>
<tr>
<th>Keyword</th>
<th>Meaning</th>
<th>Compiles To</th>
</tr>
</thead>
<tbody><tr>
<td><code>pro</code></td>
<td>&quot;for&quot; (preposition)</td>
<td><code>for...of</code></td>
</tr>
<tr>
<td><code>fit</code></td>
<td>&quot;it becomes&quot; (present)</td>
<td><code>for...of</code></td>
</tr>
<tr>
<td><code>fiet</code></td>
<td>&quot;it will become&quot; (future)</td>
<td><code>for await...of</code></td>
</tr>
</tbody></table>
<p>The <code>fit</code> form is equivalent to <code>pro</code> and can be used interchangeably for sync iteration.</p>
<h3 id="loop-control">Loop Control</h3>
<p>Two keywords control loop flow:</p>
<h4 id="rumpe-break">rumpe (Break)</h4>
<p>The keyword <code>rumpe</code> is the imperative of <em>rumpere</em> (&quot;to break&quot;). It exits the innermost loop immediately.</p>
<pre><code class="language-fab">varia i = 0

dum i &lt; 10 {
    si i == 5 {
        rumpe
    }
    scribe i
    i = i + 1
}
</code></pre>
<p>Output: 0, 1, 2, 3, 4 (loop breaks when <code>i</code> reaches 5).</p>
<p>In nested loops, <code>rumpe</code> exits only the inner loop:</p>
<pre><code class="language-fab">ex 0..3 pro outer {
    ex 0..10 pro inner {
        si inner == 2 {
            rumpe  # exits inner loop only
        }
        scribe scriptum(&quot;outer=§, inner=§&quot;, outer, inner)
    }
}
</code></pre>
<h4 id="perge-continue">perge (Continue)</h4>
<p>The keyword <code>perge</code> is the imperative of <em>pergere</em> (&quot;to continue&quot; or &quot;proceed&quot;). It skips to the next iteration.</p>
<pre><code class="language-fab">ex 0..10 pro i {
    si i % 2 == 0 {
        perge  # skip even numbers
    }
    scribe i
}
</code></pre>
<p>Output: 1, 3, 5, 7, 9 (even numbers skipped).</p>
<p>Like <code>rumpe</code>, <code>perge</code> affects only the innermost loop.</p>
<hr>
<h2 id="branching">Branching</h2>
<p>Branching statements select one path among several based on a value.</p>
<h3 id="elige-switch">elige (Switch)</h3>
<p>The keyword <code>elige</code> is the imperative of <em>eligere</em> (&quot;to choose&quot;). It matches a value against cases.</p>
<pre><code class="language-fab">fixum status = &quot;active&quot;

elige status {
    casu &quot;pending&quot; {
        scribe &quot;Waiting...&quot;
    }
    casu &quot;active&quot; {
        scribe &quot;Running&quot;
    }
    casu &quot;done&quot; {
        scribe &quot;Completed&quot;
    }
}
</code></pre>
<p>The keyword <code>casu</code> is the ablative of <em>casus</em> (&quot;case&quot; or &quot;instance&quot;)—literally &quot;in the case of.&quot;</p>
<p>Unlike C-family switch statements, Faber&#39;s <code>elige</code> does not fall through. Each <code>casu</code> is self-contained.</p>
<p>For a default branch, use <code>ceterum</code> (&quot;otherwise&quot; or &quot;for the rest&quot;):</p>
<pre><code class="language-fab">elige code {
    casu 200 {
        scribe &quot;OK&quot;
    }
    casu 404 {
        scribe &quot;Not Found&quot;
    }
    ceterum {
        scribe &quot;Unknown status&quot;
    }
}
</code></pre>
<p>One-liner cases use <code>ergo</code>:</p>
<pre><code class="language-fab">elige status {
    casu &quot;pending&quot; ergo scribe &quot;waiting&quot;
    casu &quot;active&quot; ergo scribe &quot;running&quot;
    ceterum iace &quot;Unknown status&quot;
}
</code></pre>
<p>Early returns use <code>reddit</code>:</p>
<pre><code class="language-fab">functio statusMessage(numerus code) -&gt; textus {
    elige code {
        casu 200 reddit &quot;OK&quot;
        casu 404 reddit &quot;Not Found&quot;
        casu 500 reddit &quot;Server Error&quot;
        ceterum reddit &quot;Unknown&quot;
    }
}
</code></pre>
<h3 id="discerne-pattern-match">discerne (Pattern Match)</h3>
<p>The keyword <code>discerne</code> is the imperative of <em>discernere</em> (&quot;to distinguish&quot; or &quot;discriminate&quot;). It performs exhaustive pattern matching on tagged union types (<em>discretio</em>).</p>
<p>First, define a <code>discretio</code> (tagged union):</p>
<pre><code class="language-fab">discretio Event {
    Click { numerus x, numerus y },
    Keypress { textus key },
    Quit
}
</code></pre>
<p>Then match against it:</p>
<pre><code class="language-fab">functio handle_event(Event e) -&gt; nihil {
    discerne e {
        casu Click pro x, y {
            scribe scriptum(&quot;Clicked at §, §&quot;, x, y)
        }
        casu Keypress pro key {
            scribe scriptum(&quot;Key: §&quot;, key)
        }
        casu Quit {
            scribe &quot;Goodbye&quot;
        }
    }
}
</code></pre>
<p>The <code>pro</code> keyword destructures variant fields into local bindings. For the <code>Quit</code> variant (which has no fields), the block has no <code>pro</code> clause.</p>
<p>For simple variants without data, the body can use <code>ergo</code>:</p>
<pre><code class="language-fab">discretio Status { Active, Inactive, Pending }

functio describe(Status s) -&gt; textus {
    discerne s {
        casu Active ergo redde &quot;active&quot;
        casu Inactive ergo redde &quot;inactive&quot;
        casu Pending ergo redde &quot;pending&quot;
    }
}
</code></pre>
<p>To bind the entire variant (not just its fields), use <code>ut</code>:</p>
<pre><code class="language-fab">discerne left, right {
    casu Primitivum ut l, Primitivum ut r {
        redde l.nomen == r.nomen
    }
    casu _, _ {
        redde falsum
    }
}
</code></pre>
<p>The underscore <code>_</code> is the wildcard pattern—it matches any variant without binding.</p>
<p>The difference between <code>elige</code> and <code>discerne</code>:</p>
<ul>
<li><code>elige</code> matches against primitive values (numbers, strings)</li>
<li><code>discerne</code> matches against <code>discretio</code> variants with destructuring</li>
</ul>
<hr>
<h2 id="guards-and-assertions">Guards and Assertions</h2>
<p>Guards and assertions enforce invariants—conditions that must hold for the program to proceed correctly.</p>
<h3 id="custodi-guard-block">custodi (Guard Block)</h3>
<p>The keyword <code>custodi</code> is the imperative of <em>custodire</em> (&quot;to guard&quot; or &quot;watch over&quot;). It groups early-exit conditions at the start of a function.</p>
<pre><code class="language-fab">functio divide(numerus a, numerus b) -&gt; numerus {
    custodi {
        si b == 0 {
            redde 0
        }
    }

    redde a / b
}
</code></pre>
<p>The <code>custodi</code> block creates a visual separation between validation and main logic. All precondition checks cluster together, making the function&#39;s requirements explicit.</p>
<p>Multiple guards in one block:</p>
<pre><code class="language-fab">functio processValue(numerus x) -&gt; numerus {
    custodi {
        si x &lt; 0 {
            redde -1
        }
        si x &gt; 100 {
            redde -1
        }
    }

    # Main logic, clearly separated from guards
    redde x * 2
}
</code></pre>
<p>Guards can throw instead of returning:</p>
<pre><code class="language-fab">functio sqrt(numerus n) -&gt; numerus {
    custodi {
        si n &lt; 0 {
            iace &quot;Cannot compute square root of negative number&quot;
        }
    }

    redde computeSqrt(n)
}
</code></pre>
<p>The <code>reddit</code> shorthand works within <code>custodi</code>:</p>
<pre><code class="language-fab">functio clamp(numerus value, numerus min, numerus max) -&gt; numerus {
    custodi {
        si value &lt; min reddit min
        si value &gt; max reddit max
    }

    redde value
}
</code></pre>
<p>Input validation patterns:</p>
<pre><code class="language-fab">functio createUser(textus name, textus email, numerus age) -&gt; textus {
    custodi {
        si name == nihil aut name == &quot;&quot; {
            redde &quot;Error: name required&quot;
        }
        si email == nihil aut email == &quot;&quot; {
            redde &quot;Error: email required&quot;
        }
        si age &lt; 13 {
            redde &quot;Error: must be 13 or older&quot;
        }
        si age &gt; 120 {
            redde &quot;Error: invalid age&quot;
        }
    }

    redde scriptum(&quot;User created: §&quot;, name)
}
</code></pre>
<h3 id="adfirma-assert">adfirma (Assert)</h3>
<p>The keyword <code>adfirma</code> is the imperative of <em>adfirmare</em> (&quot;to affirm&quot; or &quot;assert&quot;). It checks runtime invariants.</p>
<pre><code class="language-fab">adfirma x &gt; 0
</code></pre>
<p>If the condition is false, execution halts with an assertion error.</p>
<p>Add a message for clarity:</p>
<pre><code class="language-fab">adfirma x &gt; 0, &quot;x must be positive&quot;
adfirma name != &quot;&quot;, &quot;name must not be empty&quot;
</code></pre>
<p>Assertions differ from guards:</p>
<ul>
<li>Guards handle expected edge cases gracefully (return early, throw recoverable errors)</li>
<li>Assertions catch programming errors (bugs) that should never occur in correct code</li>
</ul>
<p>Use <code>adfirma</code> for conditions that indicate bugs if violated:</p>
<pre><code class="language-fab">functio processArray(lista&lt;numerus&gt; items) {
    adfirma items != nihil, &quot;items must not be null&quot;
    adfirma items.longitudo &gt; 0, &quot;items must not be empty&quot;

    # ... process items
}
</code></pre>
<hr>
<h2 id="summary">Summary</h2>
<table>
<thead>
<tr>
<th>Keyword</th>
<th>Latin Meaning</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td><code>si</code></td>
<td>&quot;if&quot;</td>
<td>Conditional branch</td>
</tr>
<tr>
<td><code>sin</code></td>
<td>&quot;but if&quot;</td>
<td>Else-if branch</td>
</tr>
<tr>
<td><code>secus</code></td>
<td>&quot;otherwise&quot;</td>
<td>Else branch</td>
</tr>
<tr>
<td><code>ergo</code></td>
<td>&quot;therefore&quot;</td>
<td>One-liner consequent</td>
</tr>
<tr>
<td><code>reddit</code></td>
<td>&quot;it returns&quot;</td>
<td>One-liner early return</td>
</tr>
<tr>
<td><code>dum</code></td>
<td>&quot;while&quot;</td>
<td>While loop</td>
</tr>
<tr>
<td><code>ex</code></td>
<td>&quot;from, out of&quot;</td>
<td>Iteration source</td>
</tr>
<tr>
<td><code>de</code></td>
<td>&quot;concerning&quot;</td>
<td>Key iteration source</td>
</tr>
<tr>
<td><code>pro</code></td>
<td>&quot;for&quot;</td>
<td>Iteration binding</td>
</tr>
<tr>
<td><code>fit</code></td>
<td>&quot;it becomes&quot;</td>
<td>Sync binding</td>
</tr>
<tr>
<td><code>fiet</code></td>
<td>&quot;it will become&quot;</td>
<td>Async binding</td>
</tr>
<tr>
<td><code>rumpe</code></td>
<td>&quot;break!&quot;</td>
<td>Exit loop</td>
</tr>
<tr>
<td><code>perge</code></td>
<td>&quot;continue!&quot;</td>
<td>Skip to next iteration</td>
</tr>
<tr>
<td><code>elige</code></td>
<td>&quot;choose!&quot;</td>
<td>Value switch</td>
</tr>
<tr>
<td><code>casu</code></td>
<td>&quot;in the case of&quot;</td>
<td>Switch case</td>
</tr>
<tr>
<td><code>ceterum</code></td>
<td>&quot;otherwise&quot;</td>
<td>Switch default</td>
</tr>
<tr>
<td><code>discerne</code></td>
<td>&quot;distinguish!&quot;</td>
<td>Pattern match</td>
</tr>
<tr>
<td><code>custodi</code></td>
<td>&quot;guard!&quot;</td>
<td>Guard clause block</td>
</tr>
<tr>
<td><code>adfirma</code></td>
<td>&quot;affirm!&quot;</td>
<td>Runtime assertion</td>
</tr>
</tbody></table>

    </main>
  </div>
  <footer class="footer-bar">
    <a href="https://github.com/ianzepp/faber-romanus" target="_blank" rel="noopener">
      <svg viewBox="0 0 16 16" width="18" height="18" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg>
      Visit or star on GitHub!
    </a>
  </footer>
</body>
</html>
